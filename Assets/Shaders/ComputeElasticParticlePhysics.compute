
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Emitter properites
int ParticleCount;
float3 EmitterPosition;
float EmitterRadius;

// Particle properties
float MinLife;
float MaxLife;

// Physics simulation
float DeltaTime;
float3 ConstantAcceleration;
float3 InitialAcceleration;
float DampingRatio;

// Colliders
float3 SphereColliderPosition;
float SphereColliderRadius;

// Properties of a distinct particle in the system
// MUST match GpuParticleSystem.Particle
struct Particle
{
	float3 position;
	float3 velocity;
	float3 acceleration;

	float4 color;
	float life;
	int born;
};

RWStructuredBuffer<Particle> ParticleBuffer;
StructuredBuffer<float3> VertexBuffer;

uint rng_state;

/**
 * Xorshift random number generator
 *
 * @author http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
 */
float random()
{
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);

	return float(rng_state) * (1.0 / 4294967296.0);
}

static const float PI = 3.14159265f;

// [numthreads(8,8,1)]
[numthreads(16, 1, 1)] // TODO: Better threading split 
void CSMain(uint3 id : SV_DispatchThreadID)
{
	// Seed random generator based on thread ID/current time
	// We need high numbers to get better random results, so 
	// we make this as high as possible and overflow the hell out of it
	rng_state = id.x * 100000.0 * DeltaTime;

	bool dead = ParticleBuffer[id.x].life < 0.001;

	if (dead) {
		ParticleBuffer[id.x].life = MinLife + random() * MaxLife;

		// Start at a random position in the emitter
		float angle = 2.0 * PI * random();
		float r = random() * EmitterRadius;
		
		ParticleBuffer[id.x].position = float3(
			EmitterPosition.x + cos(angle) * r,
			EmitterPosition.y,
			EmitterPosition.z + sin(angle) * r
		);

		// Set initial velocity based on our initial acceleration
		ParticleBuffer[id.x].velocity = InitialAcceleration;

		ParticleBuffer[id.x].color = float4(
			saturate(random() + 0.25), 
			saturate(random() + 0.25), 
			saturate(random() + 0.25), 
			1.0
		);
	} else {
		// Age the particle towards zero
		ParticleBuffer[id.x].life = ParticleBuffer[id.x].life - DeltaTime;

		// If the particle is already born, do physics calculations
		if (ParticleBuffer[id.x].born) {
			float3 velocity = ParticleBuffer[id.x].velocity;

			// Apply gravitational acceleration - if supplied
			float3 acceleration = ConstantAcceleration;

			// Predicted position next step before collision responses
			float3 pos = ParticleBuffer[id.x].position + (velocity + acceleration) * DeltaTime;

			float3 normal, reflection;

			// Super simple spherical collision response with a sphere
			float d = distance(pos, SphereColliderPosition);
			float rad = SphereColliderRadius + 0.1;
			if (d < rad) {
				normal = normalize(SphereColliderPosition - pos);
				reflection = velocity - 2 * dot(velocity, normal) * normal;

				// Kill acceleration and reflect velocity
				acceleration = 0;
				velocity = reflection * DampingRatio;
			}

			// Collision response with ground plane (fixed)
			// d = abs(dot(pos, normal));
			if (pos.y < 0.1) {
				reflection = velocity - 2 * dot(velocity, float3(0, 1, 0)) * float3(0, 1, 0);
				acceleration = 0;
				velocity = reflection * DampingRatio;
			}
			
			ParticleBuffer[id.x].velocity = velocity + acceleration;

			// Update position with velocity vector
			ParticleBuffer[id.x].position += ParticleBuffer[id.x].velocity * DeltaTime;
		}
		else {
			// If life times out, actually become a born particle
			if (ParticleBuffer[id.x].life < MinLife) {
				ParticleBuffer[id.x].born = 1;
				ParticleBuffer[id.x].life = 0;
			}
		}
	}

	// Change opacity based on remaining life
	ParticleBuffer[id.x].color.a = saturate(ParticleBuffer[id.x].life / MinLife);
}
