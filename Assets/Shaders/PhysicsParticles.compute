
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Constant properties of the particle system
int ParticleCount;
float4 StartColor;
float4 EndColor;
float3 EmitterPosition;
float EmitterRadius;
float MinLife;
float MaxLife;
float3 ConstantAcceleration;
float3 InitialAcceleration;
float TerminalVelocity;

// Properties of a distinct particle in the system
// MUST match GpuParticleSystem.Particle
struct Particle
{
	float3 position;
	float3 velocity;
	float3 acceleration;

	float4 color;
	float life;
};

struct CollisionSphere
{
	float3 position;
	float radius;
};

// Metadata that changes per-frame
// MUST match GpuParticleSystem.FrameMetadata
struct FrameMetadata
{
	float time;
	float3 groundPlanePosition;
	float3 groundPlaneNormal;

	float3 spherePosition;
	float sphereRadius;
};

RWStructuredBuffer<Particle> ParticleBuffer;
RWStructuredBuffer<float3> VertexBuffer;
StructuredBuffer<FrameMetadata> MetadataBuffer;
StructuredBuffer<CollisionSphere> CollisionSpheresBuffer;

uint rng_state;

/**
 * Xorshift random number generator
 *
 * @author http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
 */
float random()
{
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);

	return float(rng_state) * (1.0 / 4294967296.0);
}

static const float PI = 3.14159265f;

// [numthreads(8,8,1)]
[numthreads(16, 1, 1)] // TODO: Better threading split 
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float dt = MetadataBuffer[0].time;

	// Seed random generator based on thread ID/current time
	// We need high numbers to get better random results, so 
	// we make this as high as possible and overflow the hell out of it
	rng_state = id.x * 100000.0 * dt;

	// Set 3 vertices that represent our particle
	// TODO: This is a waste of repeated memory. See if there's a way to optimize this away.
	VertexBuffer[3 * id.x] = float3(0, 0.5, 0);
	VertexBuffer[3 * id.x + 1] = float3(-0.5, -0.5, 0);
	VertexBuffer[3 * id.x + 2] = float3(0.5, -0.5, 0);

	bool dead = ParticleBuffer[id.x].life < 0.001;

	// TODO: Less conditional branching
	if (dead) {
		ParticleBuffer[id.x].life = MinLife + random() * MaxLife;

		// Start at a random position in the emitter
		float angle = 2.0 * PI * random();
		float r = random() * EmitterRadius;

		ParticleBuffer[id.x].position = float3(
			EmitterPosition.x + cos(angle) * r,
			EmitterPosition.y,
			EmitterPosition.z + sin(angle) * r
		);

		// Hardcode an initial velocity
		ParticleBuffer[id.x].velocity = InitialAcceleration * random();

		ParticleBuffer[id.x].color = float4(
			saturate(random() + 0.25), 
			saturate(random() + 0.25), 
			saturate(random() + 0.25), 
			1.0
		);
	}
	else {
		// Age the particle towards zero
		ParticleBuffer[id.x].life = ParticleBuffer[id.x].life - dt;

		// Super simple spherical collision response with a fixed sphere
		float3 velocity = ParticleBuffer[id.x].velocity;
		float3 pos = ParticleBuffer[id.x].position + velocity;
		float3 collider = float3(0.0, -5.0, 0.0);
		float radius = 5.0;

		// Initialize acceleration with gravity - if supplied
		float3 acceleration = ConstantAcceleration;

		uint count, dummy;
		CollisionSpheresBuffer.GetDimensions(count, dummy);

		float3 normal, reflection;

		float d = distance(pos, MetadataBuffer[0].spherePosition);
		float rad = MetadataBuffer[0].sphereRadius;
		if (d < rad) {
			normal = normalize(MetadataBuffer[0].spherePosition - pos);
			reflection = velocity - 2 * dot(velocity, normal) * normal;

			// TODO: Damping multiplier?

			// Kill acceleration and reflect velocity
			acceleration = 0;
			velocity = reflection;
			// velocity = length(velocity) / length(reflection) * reflection; // * 0.7; damping factor likes to make velocity hit zero...
		}

		// Update velocity with acceleration and clamp to some
		// terminal velocity so it won't go nuts
		//ParticleBuffer[id.x].velocity = clamp(
		//	velocity + acceleration, 
		//	0, 
		//	TerminalVelocity
		//);

		ParticleBuffer[id.x].velocity = velocity + acceleration;

		// Update position with velocity vector
		ParticleBuffer[id.x].position += ParticleBuffer[id.x].velocity;
	}

	// Color is a lerp between start and end colors, based on 
	// how long this particle has been alive. TODO: In fragment shader?
	// float a = ParticleBuffer[id.x].life / MaxLife;
	// ParticleBuffer[id.x].color = float4(a, a, a, 1.0);
	// ParticleBuffer[id.x].color = float4(random(), random(), random(), 1.0);
}
