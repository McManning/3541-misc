
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Emitter properites
int ParticleCount;
float3 EmitterPosition;
float EmitterRadius;

// Particle properties
float4 StartColor;
float4 EndColor;
float MinLife;
float MaxLife;

// Physics simulation
float DeltaTime;
float3 ConstantAcceleration;
float3 InitialAcceleration;
float DampingRatio;

// Colliders
float3 SphereColliderPosition;
float SphereColliderRadius;

// Properties of a distinct particle in the system
// MUST match GpuParticleSystem.Particle
struct Particle
{
	float3 position;
	float3 velocity;
	float3 acceleration;

	float4 color;
	float life;
};

RWStructuredBuffer<Particle> ParticleBuffer;
StructuredBuffer<float3> VertexBuffer;

uint rng_state;

/**
 * Xorshift random number generator
 *
 * @author http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
 */
float random()
{
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);

	return float(rng_state) * (1.0 / 4294967296.0);
}

static const float PI = 3.14159265f;

// [numthreads(8,8,1)]
[numthreads(16, 1, 1)] // TODO: Better threading split 
void CSMain(uint3 id : SV_DispatchThreadID)
{
	// Seed random generator based on thread ID/current time
	// We need high numbers to get better random results, so 
	// we make this as high as possible and overflow the hell out of it
	rng_state = id.x * 100000.0 * DeltaTime;

	// Set 3 vertices that represent our particle
	// TODO: This is a waste of repeated memory. See if there's a way to optimize this away.
	//VertexBuffer[3 * id.x] = float3(0, 0.5, 0);
	//VertexBuffer[3 * id.x + 1] = float3(-0.5, -0.5, 0);
	//VertexBuffer[3 * id.x + 2] = float3(0.5, -0.5, 0);

	bool dead = ParticleBuffer[id.x].life < 0.001;

	// TODO: Less conditional branching
	if (dead) {
		ParticleBuffer[id.x].life = MinLife + random() * MaxLife;

		// Start at a random position in the emitter
		float angle = 2.0 * PI * random();
		float r = random() * EmitterRadius;
		
		ParticleBuffer[id.x].position = float3(
			EmitterPosition.x + cos(angle) * r,
			EmitterPosition.y,
			EmitterPosition.z + sin(angle) * r
		);

		// Initial velocity is some random factor of our initial acceleration setting
		ParticleBuffer[id.x].velocity = InitialAcceleration * random();

		ParticleBuffer[id.x].color = float4(
			saturate(random() + 0.25), 
			saturate(random() + 0.25), 
			saturate(random() + 0.25), 
			1.0
		);
	}
	else {
		// Age the particle towards zero
		ParticleBuffer[id.x].life = ParticleBuffer[id.x].life - DeltaTime;

		float3 velocity = ParticleBuffer[id.x].velocity;
		float3 pos = ParticleBuffer[id.x].position + velocity;

		// Initialize acceleration with gravity - if supplied
		float3 acceleration = ConstantAcceleration;

		float3 normal, reflection;

		// Super simple spherical collision response with a sphere
		float d = distance(pos, SphereColliderPosition);
		float rad = SphereColliderRadius + 0.1;
		if (d < rad) {
			normal = normalize(SphereColliderPosition - pos);
			reflection = velocity - 2 * dot(velocity, normal) * normal;

			// TODO: Damping multiplier?

			// Kill acceleration and reflect velocity
			acceleration = 0;
			velocity = reflection * DampingRatio;
			// velocity = length(velocity) / length(reflection) * reflection; // * 0.7; damping factor likes to make velocity hit zero...
		}

		// Collision response with ground plane (fixed)
		// d = abs(dot(pos, normal));
		if (pos.y < 0.1) {
			reflection = velocity - 2 * dot(velocity, float3(0, 1, 0)) * float3(0, 1, 0);
			acceleration = 0;
			velocity = reflection * DampingRatio;
		}

		ParticleBuffer[id.x].velocity = velocity + acceleration;

		// Update position with velocity vector
		ParticleBuffer[id.x].position += ParticleBuffer[id.x].velocity;
	}

	// Change opacity based on remaining life
	ParticleBuffer[id.x].color.a = saturate(ParticleBuffer[id.x].life / MinLife);
}
