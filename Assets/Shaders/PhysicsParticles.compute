
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Constant properties of the particle system
int ParticleCount;
float4 StartColor;
float4 EndColor;
float3 EmitterPosition;
float EmitterRadius;
float MinLife;
float MaxLife;
float3 ConstantAcceleration;
float3 InitialAcceleration;
float TerminalVelocity;

// Properties of a distinct particle in the system
// MUST match GpuParticleSystem.Particle
struct Particle
{
	float3 position;
	float3 velocity;
	float3 acceleration;

	float4 color;
	float life;
};

// Metadata that changes per-frame
// MUST match GpuParticleSystem.FrameMetadata
struct FrameMetadata
{
	float time;
};

RWStructuredBuffer<Particle> ParticleBuffer;
RWStructuredBuffer<float3> VertexBuffer;
StructuredBuffer<FrameMetadata> MetadataBuffer;

// rand_lcg() and rand_xorshift() sourced via 
// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
uint rng_state;

/**
 * Xorshift random number generator
 *
 * @author http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
 */
float random()
{
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);

	return float(rng_state) * (1.0 / 4294967296.0);
}

// [numthreads(8,8,1)]
[numthreads(16,1,1)] // TODO: Better threading split 
void CSMain (uint3 id : SV_DispatchThreadID) 
{
	/*
		Some notes:
		id is our thread index (.x/.y for a 2D set of threads). Basically
		equivalent to a texture position if pushing a texture in
	*/

	// Result[id.xy] = Color; // float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);

	float dt = MetadataBuffer[0].time;

	// Seed random generator based on thread ID/current time
	// We need high numbers to get better random results, so 
	// we make this as high as possible and overflow the hell out of it
	rng_state = id.x * 100000.0 * dt;

	// Starting position - a grid based on the index #
	int width = sqrt(ParticleCount);
	float3 position = float3(id.x % width * 0.25, id.x / width * 0.25, 0.0);

	// Basic sine wave - offsetting phase by the delta time
	//float speed = 2.0;
	//float frequency = 0.5;
	//float scale = 1.0;

	//float v = position.x * position.x + position.y * position.y;
	//position.z = scale * sin(t * speed + v * frequency);

	// Give a random interpolated color - red for low indices, green for high
	float red = (float)id / ParticleCount;
	float green = 1.0 - red;
	float blue = 0.0;

	//ParticleBuffer[id.x].position = position;
	//ParticleBuffer[id.x].color = float4(red, green, blue, 1.0);

	// Set 3 vertices that represent our particle
	// TODO: This is a waste of repeated memory. See if there's a way to optimize this away.
	VertexBuffer[3 * id.x] = float3(0, 0.5, 0);
	VertexBuffer[3 * id.x + 1] = float3(-0.5, -0.5, 0);
	VertexBuffer[3 * id.x + 2] = float3(0.5, -0.5, 0);

	bool dead = ParticleBuffer[id.x].life < 0.001;

	if (dead) {
		ParticleBuffer[id.x].life = MinLife + random() * MaxLife;

		// Start at a random position in the emitter
		ParticleBuffer[id.x].position = float3(
			// TODO: Randomness
			EmitterPosition.x + id.x % width * 0.1,
			EmitterPosition.y,
			EmitterPosition.z + id.x / width * 0.1
		);

		// Hardcode an initial velocity
		ParticleBuffer[id.x].velocity = InitialAcceleration * random();
	}
	else {
		// Decrement life
		ParticleBuffer[id.x].life = ParticleBuffer[id.x].life - dt;

		// Update position with velocity vector
		ParticleBuffer[id.x].position += ParticleBuffer[id.x].velocity;
	}

	// Color is a lerp between start and end colors, based on 
	// how long this particle has been alive. TODO: In fragment shader?
	float a = ParticleBuffer[id.x].life / MaxLife;
	ParticleBuffer[id.x].color = float4(a, a, a, 1.0);
}
